<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Request Specific Caching</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Request Specific Caching</h1>

    <section>

<header>
    

    <h2>Request Specific Caching</h2>
</header>

<article>
    <p>In graphql-tools v6, wrapping a remote schema can be easily accomplished by specifying executor and subscriber functions that target a remote schema. graphql-tools provides helper functions that convert Apollo-style links to executors and subscriber functions; simple fetcher functions can also be used.</p>
<p>To accomplish per-request batching or caching, the executor must be customized on a per-request basis. This is easily done via the context object, which the custom executor can access. The HTTPLinkDataloader link by the Prisma team enables batching and caching; if a new HttpLinkDataloader object is added to each context, the specified executor function can easily use that function to provide per request batching and caching.</p>
<p>Setup is roughly as follows, with per request caching enabled only for queries and mutations.</p>
<pre class="prettyprint source lang-javascript"><code>const { wrapSchema } = require('@graphql-tools/wrap');
const { linkToExecutor, linkToSubscriber } = require('@graphql-tools/links');
const { HTTPLinkDataloader } = require('http-link-dataloader');
const { WebSocketLink } = require('apollo-link-ws');

const schema = wrapSchema({
  schema: await createDbSchema(),
  executor: ({ document, variables, context, info }) => context.executor({ document, variables, context, info}),
  subscriber: linkToSubscriber(new WebSocketLink({ uri, /* additional options */ }),
});

const context = () => {
  return {
    executor: linkToExecutor(new HTTPLinkDataloader({ uri, /* additional options */ })),
  };
};
</code></pre>
<p>apollo-stitcher also provides a special link that uses Apollo Client to cache results, only sending queries on to the remote if the requested fields are not all in the cache. This can be combined with the above as follows:</p>
<pre class="prettyprint source lang-javascript"><code>const { ApolloClientLink } = require('apollo-stitcher');
const { ApolloClient } = require('apollo-client');
const { InMemoryCache } = require('apollo-cache-inmemory');

const context = () => {
  return {
    executor: linkToExecutor(new ApolloClientLink({
      client: new ApolloClient({
        ssrMode: true
        cache: new InMemoryCache(),
        link: linkToRemote
      })
    }))
  };
}
</code></pre>
<p>See sample repository <a href="https://github.com/yaacovCR/nextjs-graphql-starter">yaacovCR/nextjs-graphql-starter</a> for additional details.</p>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-apollo-stitcher.html">apollo-stitcher</a></li></ul><h3>Classes</h3><ul><li><a href="module-apollo-stitcher.ApolloClientLink.html">ApolloClientLink</a></li><li><a href="module-apollo-stitcher.Stitcher.html">Stitcher</a></li><li><a href="module-apollo-stitcher.TransformQuery.html">TransformQuery</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-Motivating Example.html">Motivating Example</a></li><li><a href="tutorial-Request Specific Caching.html">Request Specific Caching</a></li><li><a href="tutorial-Vanilla GraphQL.html">Vanilla GraphQL</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>